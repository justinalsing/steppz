import os
import sys
sys.path.append('/home/sinandeger/PycharmProjects/tfenv_cosmicexplorer/steppz/steppz/code')
os.environ["SPS_HOME"] = '/home/sinandeger/fsps/'
# sys.path.insert(0, '/home/sinandeger/PycharmProjects/tfenv_cosmicexplorer/steppz/steppz/sps_models/model_B')
# from sfh import sfh
import fsps
from astropy.cosmology import Planck15
from sedpy.observate import load_filters, getSED
"""Import the basics; numpy, pandas, matplotlib et al."""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats
import random
import functools
from tqdm import tqdm
from collections import defaultdict
import tensorflow as tf

import threading
import concurrent.futures
from multiprocessing import Pool

from sfh_templates import continuity_prior_timebins
# from utils import distance_modulus
from utils import distance_modulus

"""This module tests the population prior distriburions generated by sample_from_population_prior"""

"""First, define where the parameters files live"""
cwd_ = os.getcwd()
print(cwd_)
parameters_path = cwd_+'/parameters/'
print(parameters_path)
"""Load one of the parameter files generated by sample_from_population_prior"""
arb_param_file = np.load(parameters_path+'parameters0.npy')
print(np.shape(arb_param_file))
n_time_bins = 7
# parameter_names = ['N', 'gaslog10Z'] + ['logsfr_ratio{}'.format(i) for i in range(1, n_time_bins)] + ['dust2', 'dust_index', 'dust1_fraction', 'z']
parameter_names = ['N', 'gaslog10Z'] + ['logsfr_ratio{}'.format(i) for i in range(1, n_time_bins)] + ['dust2', 'dust_index', 'dust1_fraction', 'z']
"""Populate a pandas dataframe with the parameters array & parameter names"""
parameter_df = pd.DataFrame(data=arb_param_file, columns=parameter_names)
"""Turn the index column into an ID column"""
# parameter_df['ID'] = parameter_df.index + 1
# print(parameter_df.shape)
# print(parameter_df.iloc[1])
print('Parameter dataframe columns: ', parameter_df.columns)
"""Convert N to log10M?"""
parameter_df['mstar'] = (parameter_df['N'].values - distance_modulus(tf.math.maximum(1e-5, parameter_df['z'].values))) / (-2.5)

fig, axs = plt.subplots(1, 2)
fig.set_size_inches(12, 6)
axs[0].hist(parameter_df['z'], bins=80, fill=False, histtype='step', linewidth=2, color='darkslategray')
axs[0].set_xlabel('Redshift')

axs[1].hist(parameter_df['mstar'], bins=80, fill=False, histtype='step', linewidth=2, color='xkcd:dusty lavender')
axs[1].set_xlabel('$\mathrm{log_{10}(M_{*})}$')

plt.subplots_adjust(wspace=0.12)
plt.savefig('redshift_log_mstar_dist.pdf', format='pdf', bbox_inches='tight')
plt.close()

#########################
# z1_ = tf.constant(0.2)
# z2_ = tf.constant(1.6)
# z3_ = tf.constant(3.0)
#
# anchor_points_logphi1_ = tf.constant(np.array([-2.44, -3.08, -4.14]).astype(np.float32))
# anchor_points_logphi2_ = tf.constant(np.array([-2.89, -3.29, -3.51]).astype(np.float32))
# anchor_points_M_star_ = tf.constant(np.array([10.79, 10.88, 10.84]).astype(np.float32))
# # Joel
# alpha1_ = tf.constant(-0.28)
# alpha2_ = tf.constant(-1.48)
# def anchor_points_to_coefficients(anchor_points):
#     a = (anchor_points[2] - anchor_points[0] + (anchor_points[1] - anchor_points[0]) * (z1_ - z3_) / (z2_ - z1_)) / (
#                 z3_ ** 2 - z1_ ** 2 + (z2_ ** 2 - z1_ ** 2) * (z1_ - z3_) / (z2_ - z1_))
#     b = (anchor_points[1] - anchor_points[0] - a * (z2_ ** 2 - z1_ ** 2)) / (z2_ - z1_)
#     c = anchor_points[0] - a * z1_ ** 2 - b * z1_
#
#     return a, b, c
#
# def compute_phi12_mstar(z):
#     a1, b1, c1 = anchor_points_to_coefficients(anchor_points_logphi1_)
#     a2, b2, c2 = anchor_points_to_coefficients(anchor_points_logphi2_)
#     aM, bM, cM = anchor_points_to_coefficients(anchor_points_M_star_)
#
#     phi1 = 10 ** (a1 * z ** 2 + b1 * z + c1)
#     phi2 = 10 ** (a2 * z ** 2 + b2 * z + c2)
#     Mstar = aM * z ** 2 + bM * z + cM
#
#     return phi1, phi2, Mstar
# def mass_function_log_prob(log10M, z):
#     phi1, phi2, Mstar = compute_phi12_mstar(z)
#
#     # normalization: NOTE THIS NORMALIZES THE MASS FUNCTION OVER LOG10M [7, 13] UP TO Z = 2.5
#     # log_normalization = tf.math.log(-0.00746909 * z**3 + 0.04891415 * z**2 - 0.13758815*z + 0.20274272)
#
#     return tf.math.log(ln10_ * (
#                 phi1 * 10 ** ((log10M - Mstar) * (alpha1_ + 1)) * tf.exp(-10 ** (log10M - Mstar)) + phi2 * 10 ** (
#                     (log10M - Mstar) * (alpha2_ + 1)) * tf.exp(-10 ** (log10M - Mstar))))  # - log_normalization
#
#
# mstar_arr = np.linspace(start=7, stop=13, num=1000)
# z_arr = np.zeros(shape=np.shape(mstar_arr)[0])
#
# test_ = mass_function_log_prob(mstar_arr, z_arr)
# print(np.shape(test_))
# plt.plot(mstar_arr, test_)
# plt.show()
# plt.close()
# input()
#

def compute_sfr(data_df, num_bins):

    """This function computes the SFR per bin per object"""
    ssfr_array = np.zeros(shape=data_df.shape[0])

    """Initialize a dictionary that will host the SFR's per bin"""
    sfr_dict = defaultdict(list)


    for obj_ind_, obj_ in enumerate(tqdm(data_df['ID'].values)):
    # for obj_ind_, obj_ in enumerate(data_df['ID'].head(5000).values):
        """tuniv: Age of the universe in Gyr at redshift z"""
        tuniv = Planck15.age(data_df.loc[data_df['ID'] == obj_]['z'].item()).value
        # print('Redshift: ', data_df.loc[data_df['ID'] == obj_]['z'].item())
        # print('Age of the universe in Gyr at z: ', tuniv)
        log_time_grid, fsps_grid = continuity_prior_timebins(num_bins, tuniv)
        time_grid_yr = [np.power(10, log_t_) for log_t_ in log_time_grid[1:]]
        time_grid_yr.insert(0, 0.0)
        # print(time_grid_yr)
        sfr_ratio_cols = [col_ for col_ in data_df.columns if 'logsfr_ratio' in col_]

        """Convert N to log10M, I think?"""  # remove this part, log Mstar already added as a column above.
        log10M = (data_df.loc[data_df['ID'] == obj_]['N'].item() - distance_modulus(data_df.loc[data_df['ID'] == obj_]['z'].item())) / (-2.5)
        # log10M.numpy() converts to flaoting variable

        nonnorm_sfr = np.ones(num_bins)

        """First, populate an array of non-normalized SFR's"""
        for sf_bin_ in range(1, num_bins):
            nonnorm_sfr[sf_bin_] = nonnorm_sfr[sf_bin_ - 1] * np.power(10, data_df.loc[data_df['ID'] == obj_][sfr_ratio_cols].values[0, sf_bin_ - 1])

        """Normalize the non-norm SFR"""
        norm_sfr = nonnorm_sfr / np.sum(nonnorm_sfr * (np.array(time_grid_yr[1:]) - np.array(time_grid_yr[0:-1])))
        """Populate the sfr_dict"""
        sfr_dict['ID'].append(obj_)
        for sfr_bin_ind_, sfr_bin_ in zip(range(1, num_bins+1), norm_sfr):
            sfr_dict['sfr_bin'+str(sfr_bin_ind_)].append(sfr_bin_)

        norm_sfr_tot_mass = norm_sfr * np.power(10, log10M.numpy())

        """Find the specific star formation rate where the SFR is averaged over the last 100 Myr"""

        log_ssfr_100myr = np.log10((norm_sfr[0] * (time_grid_yr[1] - time_grid_yr[0]) + norm_sfr[1] * (time_grid_yr[2] - time_grid_yr[1])) /
                                   (time_grid_yr[2]))
        ssfr_array[obj_ind_] = log_ssfr_100myr

    data_df['log_sSFR'] = ssfr_array.tolist()
    # data_df.insert(loc=, column='log_sSFR', value=pd.Series(ssfr_array.tolist()))
    sfr_df = pd.DataFrame.from_dict(sfr_dict)
    merged_df = pd.merge(data_df, sfr_df, on='ID', how='left')
    merged_df.to_csv('modified_parameters_file.csv')


# ssfr_thread = threading.Thread(target=compute_sfr, args=[parameter_df, n_time_bins])
# ssfr_thread.start()

# pool = Pool(14)
# pool.map(compute_sfr(parameter_df, n_time_bins))
# pool.close()

with concurrent.futures.ThreadPoolExecutor() as executor:
    compute_ = executor.submit(compute_sfr, parameter_df, n_time_bins)
    modified_parameter_ = compute_.result()
    # modified_parameter_df.to_csv('modified_parameters_file.csv')

# modified_parameter_df = compute_sfr(parameter_df, num_bins=n_time_bins)

# sfr_thread = threading.Thread(target=compute_sfr, args=(parameter_df, n_time_bins))
# sfr_thread.start()
# sfr_thread.join()

modified_parameter_df = pd.read_csv('modified_parameters_file.csv')

plt.hist(modified_parameter_df['log_sSFR'], bins=80, fill=False, histtype='step', linewidth=2.5, color='steelblue')
plt.xlabel('log10(sSFR_100Myr)')
plt.savefig('log_ssfr_100Myr_dist_test.pdf', format='pdf', bbox_inches='tight')
plt.close()

# plt.scatter(np.power(10, modified_parameter_df.loc[(modified_parameter_df['z'] < 2.01) & (modified_parameter_df['z'] > 1.99)]['mstar'].values),
#             modified_parameter_df.loc[(modified_parameter_df['z'] < 2.01) & (modified_parameter_df['z'] > 1.99)]['sfr_bin1'], c='darkslategray')
# plt.show()

